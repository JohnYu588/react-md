# Autocomplete

An `AutoComplete` is a component that allows for real-time suggestions from a
pre-determined list as the user types by filtering data based on the current
value. It can also be used to interact with an API that handles the sorting,
filtering, matching, etc as well.

# Simple Example

An `Autocomplete` requires a list of options which can be strings or an object
with a `label` string so that the options can be filtered as the user types. In
addition, a `listboxLabel` or `listboxLabelledby` prop must be defined for
accessibility to provide a label for the listbox.

```demo source="./SimpleExample.tsx"

```

## Simple Label Example

This is the same example as above, but using options as `{ label: string }`.

```demo source="./SimpleLabelExample.tsx"

```

# Object Options

The `Autocomplete` can support any object option by also providing an
`getOptionLabel` prop that will return a string value for each option.

> !Info! See [Typescript Typing](#typescript-typing) for type behavior.

```demo source="./ObjectOptionsExample.tsx"

```

# Option Props

The `Autocomplete` will automatically pass through common `Option` props that
exist on each option.

```demo source="./OptionPropsExample.tsx"

```

## Get Option Props

Another way to pass props to each option is using the `getOptionProps` function.

```demo source="./GetOptionPropsExample.tsx"

```

## Disabled Options

An option can be disabled by adding `disabled: true` to the option or using `getOptionProps`
to return `disabled: true`.

```demo source="./DisabledOptionsExample.tsx"

```

# Controlling the Value

If the current value is needed, provide a `value` and `setValue` prop.

```demo source="./ControllingTheValueExample.tsx"

```

## Setting a default value

If the value does not need to be controlled but one of the options should
be selected by default, set the `defaultValue` prop instead.

> !Info! See [Typescript Typing](#typescript-typing) for type behavior.

```demo source="./SettingADefaultValueExample.tsx"

```

## Controlling the input value

If the input value needs to be controlled, provide a `query` and `setQuery` prop.

```demo source="./ControllingTheInputValueExample.tsx"

```

## Getting the current input value

If the input value doesn't need to be controlled, the value can be retrieved
with the normal `onChange` event handler.

```demo source="./GettingTheCurrentInputValueExample.tsx"

```

# Async Example

The `Autocomplete` supports rendering a `CircularProgress` after the input field to show
async behavior. The `CircularProgress` will be shown while the `loading` prop is true.

This example below will "load" the options each time the autocomplete is opened.

```demo source="./AsyncExample.tsx"

```

## Debounced Search Example

When the `Autocomplete` should be used as a `<input type="search" />` to send
requests to an API as the user types to get the options, set the `type="search"`
and add a custom `onChange` handler to send the current value to the search API.
It is recommended to either debounce or throttle these search requests so that
each keystroke is not a new request.

`react-md` provides two hooks to help with debouncing and throttling:

- [useDebouncedFunction](/hooks/use-debounced-function)
- [useThrottledFunction](/hooks/use-throttled-function)

This example will show a debounced implementation while the next example will
show a throttled implementation.

```demo source="./DebouncedSearchExample.tsx"

```

## Throttled Search Example

This is the same example as above, but using [useThrottledFunction](/hooks/use-throttled-function)
instead.

```demo source="./ThrottledSearchExample.tsx"

```

# Custom Filter Function

The `Autocomplete` uses the
[caseInsensitiveSearch](/utils/case-insensitive-search) filter function by
default but can be changed using the `filter` prop. The filter function must
return the filtered list and is called with an object containing:

- `list` - The list of `options` to filter
- `query` - The current text field value
- `extractor` - The `extractor` function to get a string for each option

This example will show how the filter function could be swapped out for the
[fuzzySearch](/utils/fuzzy-search).

```demo source="./CustomFilterFunctionExample.tsx"

```

# Typescript Typing

The `Autocomplete` option is defined as:

```ts disableTransform
type AutocompleteLabeledOption = string | { label: string };
type AutocompleteOption = AutocompleteLabeledOption | {};
```

Each option should extend this type and will automatically be inferred for
almost all use cases.

```tsx disableTransform
// ✅ Inferred as `string[]`
<Autocomplete {...props} options={["One", "Two", "Three"]} />;

// ✅ Inferred as `string[]`
const options = ["One", "Two", "Three"];
<Autocomplete {...props} options={options} />;

// ✅ Inferred as `("One" | "Two" | "Three")[]`
const options = ["One", "Two", "Three"] as const;
<Autocomplete {...props} options={options} />;

// ✅ Inferred as `{ name: string, value: number }`
const options = [
  { name: "Hello", value: 1 },
  { name: "World", value: 2 },
];
<Autocomplete
  {...props}
  options={options}
  getOptionLabel={(option) => option.name}
/>;

// ✅ Inferred as `State`
interface State {
  name: string;
  abbreviation: string;
}
const options: readonly State[] = [
  { name: "Virginia", abbreviation: "VA" },
  { name: "Whyoming", abbreviation: "WY" },
];
<Autocomplete
  {...props}
  options={options}
  getOptionLabel={(state) => state.name}
/>;
```

The only time it appears to have an issue is when the list of options are
defined with `as const`:

```tsx disableTransform
const options = [
  { name: "Virginia", abbreviation: "VA" },
  { name: "Whyoming", abbreviation: "WY" },
] as const;
<Autocomplete
  {...props}
  options={options}
  // ❌ Parameter 'state' implicity has an `any` type.
  getOptionLabel={(state) => state.name}
/>;
```

The type issue can be resolved by one of the following:

```tsx disableTransform
const options = [
  { name: "Virginia", abbreviation: "VA" },
  { name: "Whyoming", abbreviation: "WY" },
] as const;

type State = (typeof options)[number];

// 1. Provide the type definition to the `getOptionLabel` parameter
<Autocomplete
  {...props}
  // ✅ `state` and `options` are set to the `State` type
  options={options}
  getOptionLabel={(state: State) => state.name}
/>;

// 2. Provide the type definition as the `Autocomplete` type parameter
<Autocomplete<State>
  {...props}
  // ✅ `state` and `options` are set to the `State` type
  options={options}
  getOptionLabel={(state) => state.name}
/>;

// 3. Cast the options to a new list:
<Autocomplete
  {...props}
  // ✅ `state` and `options` are set to the `State` type
  options={options as State[]}
  getOptionLabel={(state) => state.name}
/>;

// 4. Redefine the list:
const states: readonly State[] = options;
<Autocomplete
  {...props}
  // ✅ `state` and `options` are set to the `State` type
  options={states}
  getOptionLabel={(state) => state.name}
/>;

// 5. Provide a `defaultValue`
const defaultValue: State | null = null

<Autocomplete
  {...props}
  defaultValue={defaultValue}
  // ✅ `state` and `options` are set to the `State` type
  options={options}
  getOptionLabel={(state) => state.name}
/>;

// 6. Control the value:
const [value, setValue] = useState<State | null>(null);
<Autocomplete
  {...props}
  value={value}
  setValue={setValue}
  // ✅ `state` and `options` are set to the `State` type
  options={options}
  getOptionLabel={(state) => state.name}
/>;
```

# Accessibility

The `Autocomplete` component implements the
[combobox](https:://www.w3.org/WAI/ARIA/apg/practices/keyboard-interface/#kbd_focus_activedescendant)
so the `<input />` will remain focused while the options gain styles to show
they are focused.

## Labels

- The listbox requires an `aria-label`/`aria-labelledby` by the
  `listboxLabel`/`listboxLabelledby` props respectively
- The dropdown button defaults to an `aria-label`/`aria-labelledby` based on the
  `listboxLabel`/`listboxLabelledby` props respectively
- The inline circular progress bar defaults to an `aria-label="Loading"`

## Keyboard Movement

The following keyboard movement has been implemented:

### Closed Listbox

- Typing will open the listbox and keep focus on the input.
- `ArrowDown` - Opens the listbox and focuses the first option.
- `Alt+ArrowDown` - Opens the listbox and keeps focus on the input.
- `ArrowUp` - Opens the listbox and focuses the last option.
- `Escape` - Clears the value.
- `Home`/`End` - Moves cursor to the start and end of the input

### Open Listbox

- Typing will move focus back to the input
- `ArrowDown` - Moves focus to the next option in the listbox. If focus was on
  the input, the first option will be focused.
- `ArrowUp` - Moves focus to the previous option in the listbox. If focus was on
  the input, the last option will be focused.
- `Alt+ArrowUp` - If an option is focused, moves focus into the input. If the
  input is focused, closes the listbox.
- `ArrowLeft`/`ArrowRight`/`Home`/`End` - Moves focus into the input and uses
  default text editing behavior for these keys.
- `Escape` - Hides the listbox.
