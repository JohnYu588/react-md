# Recipes

This page will provide common testing recipes for components through ReactMD.

> !Warn! All examples assume that fake timers are not enabled. Enable at your
> own debugging risk!

# Inputs

## Autocomplete

TODO

## Checkbox

### Find and Change Value

The `Checkbox` can be found like any other checkbox element:

```tsx
import { render, screen, userEvent } from "@react-md/core-test-utils";

it("should be able to change value", async () => {
  const user = userEvent.setup();
  rmdRender(<Checkbox label="Label" />);

  const checkbox = screen.getByRole("checkbox", { name: "Label" });
  expect(checkbox).not.toBeChecked();

  await user.click(checkbox);
  expect(checkbox).toBeChecked();

  await user.click(checkbox);
  expect(checkbox).not.toBeChecked();
});
```

## Radio

### Find and Change Value

The `Radio` can be found like any other radio element:

```tsx
function Test(): ReactElement {
  const { getRadioProps } = useRadioGroup({ name: "example" });

  return (
    <Form>
      <Radio {...getRadioProps("a")} label="First" />
      <Radio {...getRadioProps("b")} label="Second" />
      <Radio {...getRadioProps("c")} label="Third" />
      <Radio {...getRadioProps("d")} label="Forth" />
    </Form>
  );
}

it("should be able to change value", async () => {
  const user = userEvent.setup();
  render(<Test />);
  const radio1 = screen.getByRole("radio", { name: "First" });
  const radio2 = screen.getByRole("radio", { name: "Second" });
  const radio3 = screen.getByRole("radio", { name: "Third" });
  const radio4 = screen.getByRole("radio", { name: "Forth" });

  expect(radio1).toHaveAttribute("value", "a");
  expect(radio2).toHaveAttribute("value", "b");
  expect(radio3).toHaveAttribute("value", "c");
  expect(radio4).toHaveAttribute("value", "d");
  expect(radio1).not.toBeChecked();
  expect(radio2).not.toBeChecked();
  expect(radio3).not.toBeChecked();
  expect(radio4).not.toBeChecked();

  await user.click(radio1);
  expect(radio1).toBeChecked();
  expect(radio2).not.toBeChecked();
  expect(radio3).not.toBeChecked();
  expect(radio4).not.toBeChecked();

  await user.click(radio3);
  expect(radio1).not.toBeChecked();
  expect(radio2).not.toBeChecked();
  expect(radio3).toBeChecked();
  expect(radio4).not.toBeChecked();
});
```

## Select

> All of these examples will use the [Simple Select](/components/select#simple-select) example code.

### Find and Change Value

This example showcases how to:

- find the `Select` component
- find and verify the current selected option
- change the selected option

```tsx
import { rmdRender, screen, userEvent } from "@react-md/core/test-utils";

it("should be able to change value", async () => {
  const user = userEvent.setup();
  rmdRender(<SimpleSelect />);

  // this is the clickable element that allows the listbox of options to appear
  const select = screen.getByRole("combobox", { name: "Label" });
  // this stores the current value
  const selectInput = screen.getByRole("textbox", { hidden: true });
  expect(selectInput).toHaveValue("");

  await user.click(select);
  // the `name` should be the accessible text in any of the available options
  await user.click(screen.getByRole("option", { name: "Option 1" }));
  expect(selectInput).toHaveValue("a");

  await user.click(select);

  // the `Option 1` should now be selected
  expect(() =>
    screen.getByRole("option", { name: "Option 1", selected: true })
  ).not.toThrow();
});
```

### Verify the Display Value

This example showcases how to find and verify the selected option's display
value while the Select listbox is closed using the `getSelectTestElements` test
util query.

```tsx
import {
  getSelectTestElements,
  rmdRender,
  screen,
  userEvent,
} from "@react-md/core/test-utils";

it("should be able to verify the display value", async () => {
  const user = userEvent.setup();
  rmdRender(<SimpleSelect />);

  const { select, selectInput, selectedOption } = getSelectTestElements({
    name: "Label",
  });
  // this isn't required, but added to show what element this is
  expect(selectedOption).toHaveClass("rmd-selected-option");

  // there is currently no selected value
  expect(selectedOption).toHaveTextContent("");

  await user.click(select);
  await user.click(screen.getByRole("option", { name: "Option 1" }));
  expect(selectInput).toHaveValue("a");
  expect(selectedOption).toHaveTextContent("Option 1");
});
```

## Slider

### Find and Change Value

Tests including the `Slider` are generally setup to include verifying the
current value and optionally changing it. The slider element can be found
using `screen.getByRole("slider", { name: "THE_SLIDER_LABEL" })` which can
be used to verify the current numeric value and update through touch, drag,
or keyboard events.

Since updating through touch, drag, or keyboard events aren't convenient for
tests, it's recommended to find the hidden `<input type="range" />` and trigger
a change event on that instead and could be found by
`screen.getByRole("slider", { name: "", hidden: true })`.

ReactMD provides a React Testing Library query named `getSliderTestElements`
that can be used to get the `slider` element and the `sliderInput`.

```tsx
import {
  fireEvent,
  getSliderTestElements,
  rmdRender,
  screen,
} from "@react-md/core/test-utils";

it("should be able to change the value", async () => {
  rmdRender(<HorizontalSlider />);

  // `name` is the accessible label for the `Slider`
  const { slider, sliderInput } = getSliderTestElements({ name: "Slider" });
  expect(slider).toHaveValue(50);
  expect(sliderInput).toHaveValue("50");

  fireEvent.change(sliderInput, { target: { value: "80" } });
  expect(slider).toHaveValue(80);
  expect(sliderInput).toHaveValue("80");
});
```

### Find and Change Value (Range Slider)

ReactMD provides another React Testing Library query named `getRangeSliderTestElements`
that can be used for a range slider. It will return the `minSlider`,
`minSliderInput`, `maxSlider`, and `maxSliderInput` allowing the values to be
verified like the normal slider.

```tsx
import {
  fireEvent,
  getRangeSliderTestElements,
  rmdRender,
  screen,
} from "@react-md/core/test-utils";

import RangeSlider from "../RangeSlider.jsx";

it("should be able to change the value", async () => {
  rmdRender(<RangeSlider defaultValue={[30, 60]} />);

  const { minSlider, minSliderInput, maxSlider, maxSliderInput } =
    getRangeSliderTestElements();
  expedct(minSlider).toHaveValue(30);
  expedct(minSliderInput).toHaveValue("30");
  expedct(maxSlider).toHaveValue(60);
  expedct(maxSliderInput).toHaveValue("60");

  fireEvent.change(minSliderInput, { target: { value: "50" } });
  expect(slider).toHaveValue(50);
  expect(sliderInput).toHaveValue("50");
  expedct(maxSlider).toHaveValue(60);
  expedct(maxSliderInput).toHaveValue("60");
});
```

## Switch

### Find and Toggle

The `Switch` is an extension of an `<input type="checkbox">` with
`role="switch"`, so the element can be changed just like a `Checkbox`.

```tsx
import { rmdRender, screen, userEvent } from "@react-md/core/test-utils";

it("should be able to change the checked state", async () => {
  const user = userEvent.setup();
  rmdRender(<Switch label="Label" />);

  const switchElement = screen.getByRole("switch", { name: "Label" });
  expect(switchElement).not.toBeChecked();

  await user.click(switchElement);
  expect(switchElement).toBeChecked();
});
```

# Presentation

## Tooltip

### Find and Verify Tooltip

A tooltip can be found using using `.getByRole("tooltip")` or
`.findByRole("tooltip")` along with the `hover` event:

> !Success! This example will also work with custom `useTooltip` usage and by
> changing the button to the tooltipped element.

```tsx
render(
  <TooltippedButton tooltip={<span>Some Tooltip</span>}>
    Button
  </TooltippedButton>
);

const button = screen.getByRole("button", { name: "Button" });

expect(() => screen.getByRole("tooltip")).toThrow();

await user.hover(button);

// change `name` to the tooltip text or another query
const tooltip = screen.getByRole("tooltip", { name: "Some Tooltip" });
expect(tooltip).toBeInTheDocument();

await user.unhover(button);
expect(tooltip).not.toBeInTheDocument();
```

# Navigation

## Menu

TODO

## Tabs

All of the tab tests will use the following test setup:

```tsx
type TestProps = Omit<TabsHookOptions, "activeTab" | "setActiveTab"> &
  Pick<TabListProps, "activationMode">;

function Test(props: TestProps): ReactElement {
  const { activationMode, ...options } = props;
  const { getTabProps, getTabListProps, getTabPanelProps, getTabPanelsProps } =
    useTabs(options);

  return (
    <>
      <TabList {...getTabListProps()} activationMode={activationMode}>
        <Tab {...getTabProps(0)}>Tab 1</Tab>
        <Tab {...getTabProps(1)}>Tab 2</Tab>
        <Tab {...getTabProps(2)}>Tab 3</Tab>
      </TabList>
      <SlideContainer {...getTabPanelsProps()} data-testid="panels">
        <Slide {...getTabPanelProps(0)}>Tab 1 Content</Slide>
        <Slide {...getTabPanelProps(1)}>Tab 2 Content</Slide>
        <Slide {...getTabPanelProps(2)}>Tab 3 Content</Slide>
      </SlideContainer>
    </>
  );
}
```

### Verify Selected Tab and Change Tabs

Each tab can be found by using the `"tab"` role while the tab panel can be
found using the `"tabpanel"` role. The inactive tab panels are hidden using
`display: none` by default so the visibility can be tested using the
[isElementVisible util](#%EF%B8%8F-iselementvisible-util).

```tsx
import { Tab } from "@react-md/core/tabs/Tab.js";
import { TabList, type TabListProps } from "@react-md/core/tabs/TabList.js";
import { type TabsHookOptions, useTabs } from "@react-md/core/tabs/useTabs.js";
import { Slide } from "@react-md/core/transition/Slide.js";
import { SlideContainer } from "@react-md/core/transition/SlideContainer.js";
import { isElementVisible } from "@react-md/core/utils/isElementVisible.js";

it("should test something...", async () => {
  const user = userEvent.setup();
  rmdRender(<Test />);

  const tab1 = screen.getByRole("tab", { name: "Tab 1" });
  const tab2 = screen.getByRole("tab", { name: "Tab 2" });
  const tab3 = screen.getByRole("tab", { name: "Tab 3" });
  const panel1 = screen.getByRole("tabpanel", { name: "Tab 1" });
  const panel2 = screen.getByRole("tabpanel", { name: "Tab 2" });
  const panel3 = screen.getByRole("tabpanel", { name: "Tab 3" });

  expect(tab1).toHaveAttribute("aria-selected", "true");
  expect(tab2).toHaveAttribute("aria-selected", "false");
  expect(tab3).toHaveAttribute("aria-selected", "false");
  expect(isElementVisible(panel1)).toBe(true);
  expect(isElementVisible(panel2)).toBe(false);
  expect(isElementVisible(panel3)).toBe(false);

  await user.click(tab2);
  expect(tab1).toHaveAttribute("aria-selected", "false");
  expect(tab2).toHaveAttribute("aria-selected", "true");
  expect(tab3).toHaveAttribute("aria-selected", "false");
  expect(isElementVisible(panel1)).toBe(false);
  expect(isElementVisible(panel2)).toBe(true);
  expect(isElementVisible(panel3)).toBe(false);
});
```

## Tree

TODO

# Feedback

## Dialog/Sheet

TODO

## Snackbar

TODO

# Layout

## Expansion Panel

All of the examples below will use this following test component:

```tsx
interface TestProps extends ExpansionPanelHookOptions {
  manualIds?: boolean;
  disablePanel2?: boolean;
}

function Test(props: TestProps): ReactElement {
  const { manualIds, ...options } = props;
  const { getPanelProps } = useExpansionPanels(options);

  return (
    <ExpansionList>
      <ExpansionPanel
        {...getPanelProps(manualIds ? "panel-1" : 0)}
        headerChildren="Panel 1"
      >
        Panel 1 Contents
      </ExpansionPanel>
      <ExpansionPanel
        {...getPanelProps(manualIds ? "panel-2" : 1)}
        headerChildren="Panel 2"
      >
        Panel 2 Contents
      </ExpansionPanel>
      <ExpansionPanel
        {...getPanelProps(manualIds ? "panel-3" : 2)}
        headerChildren="Panel 3"
      >
        Panel 3 Contents
      </ExpansionPanel>
    </ExpansionList>
  );
}
```

### Find and Verify Expansion

Each expansion panel can be found using the `"button"` role while the panel
contents can be found using the `"region"` role. The collapsed panel contents
are hidden using `display: none` by default so the visibility can be tested
using the [isElementVisible util](#%EF%B8%8F-iselementvisible-util).

```tsx
it("should test something", async () => {
  const user = userEvent.setup();
  render(<Test />);
  const panel1 = screen.getByRole("button", { name: "Panel 1" });
  const panel2 = screen.getByRole("button", { name: "Panel 2" });
  const panel3 = screen.getByRole("button", { name: "Panel 3" });

  const [panel1Contents, panel2Contents, panel3Contents] =
    screen.getAllByRole("region");

  expect(panel1).toHaveAttribute("aria-expanded", "false");
  expect(panel2).toHaveAttribute("aria-expanded", "false");
  expect(panel3).toHaveAttribute("aria-expanded", "false");
  expect(panel1Contents).toBeInTheDocument();
  expect(panel2Contents).toBeInTheDocument();
  expect(panel3Contents).toBeInTheDocument();
  expect(isElementVisible(panel1Contents)).toBe(false);
  expect(isElementVisible(panel2Contents)).toBe(false);
  expect(isElementVisible(panel3Contents)).toBe(false);

  await user.click(panel3);
  expect(panel1).toHaveAttribute("aria-expanded", "false");
  expect(panel2).toHaveAttribute("aria-expanded", "false");
  expect(panel3).toHaveAttribute("aria-expanded", "true");
  expect(panel1Contents).toBeInTheDocument();
  expect(panel2Contents).toBeInTheDocument();
  expect(panel3Contents).toBeInTheDocument();
  expect(isElementVisible(panel1Contents)).toBe(false);
  expect(isElementVisible(panel2Contents)).toBe(false);
  expect(isElementVisible(panel3Contents)).toBe(true);
});
```

# ⚠️ isElementVisible util

> !Warn! The `isElementVisible` util really only verifies that the element or
> any parent elements do not contain the `"rmd-display-none"` class. A custom
> util will be required for components not apart of `react-md` or custom
> styling to hide panels.
