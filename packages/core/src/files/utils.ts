import { type ChangeEventHandler, type DragEventHandler } from "react";

/** @since 2.9.0 */
export interface BaseFileUploadStats {
  /**
   * A unique key associated with each upload generated by `nanoid`.
   */
  key: string;

  /**
   * The file instance that is being uploaded.
   */
  file: File;

  /**
   * The current upload progress as a percentage from 0 - 100 percent.
   */
  progress: number;
}

/** @since 2.9.0 */
export interface ProcessingFileUploadStats extends BaseFileUploadStats {
  status: "pending" | "uploading";
}

/** @since 2.9.0 */
export type FileReaderResult = FileReader["result"];

/** @since 2.9.0 */
export interface CompletedFileUploadStats extends BaseFileUploadStats {
  status: "complete";

  /**
   * The result after a `FileReader` has read a file completely.
   *
   * Note: This _should_ be an `ArrayBuffer` if the next step is to upload to a
   * server.
   *
   * @see {@link FileReaderParser}
   * @see {@link getFileParser}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/FileReader | FileReader}
   */
  result: FileReaderResult;
}

/** @since 2.9.0 */
export type FileUploadStats =
  | ProcessingFileUploadStats
  | CompletedFileUploadStats;

/** @since 2.9.0 */
export type FileUploadStatus = FileUploadStats["status"];

/** @since 2.9.0 */
export interface FileUploadHandlers<E extends HTMLElement> {
  onDrop?: DragEventHandler<E>;
  onChange?: ChangeEventHandler<HTMLInputElement>;
}

/**
 * This will first check if the mime-type of the file starts with `text/` and
 * fallback to checking a few file names or extensions that should be considered
 * text.
 *
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file should be considered as a text-content file.
 * @since 2.9.0
 */
export function isTextFile(file: File): boolean {
  return /\.((j|t)sx?|json|lock|hbs|ya?ml|log|txt|md)$/i.test(file.name);
}

/**
 * This will first check if the mime-type of the file starts with `text\/` and
 * fallback to checking a few file names or extensions that should be considered
 * text.
 *
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file should be considered as a text content file.
 * @since 2.9.0
 */
export function isImageFile(file: File): boolean {
  return /\.(a?png|avif|svg|tiff|gifv?|jpe?g)/i.test(file.name);
}

/**
 * This will first check if the mime-type of the file starts with `audio/` and
 * fallback to checking a few file names or extensions that should be considered
 * audio.
 *
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file should be considered as a audio content file.
 * @since 2.9.0
 */
export function isAudioFile(file: File): boolean {
  return /\.(mp3|wav|ogg|m4p|flac)$/i.test(file.name);
}

/**
 * This will first check if the mime-type of the file starts with `video/` and
 * fallback to checking a few file names or extensions that should be considered
 * video.
 *
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file should be considered as a video content file.
 * @since 2.9.0
 */
export function isVideoFile(file: File): boolean {
  return /\.(mkv|mpe?g|mov|avi|flv|webm|mp4)$/i.test(file.name);
}

/**
 * This function is not guaranteed to be 100% correct and is only useful if
 * trying to generate a preview of files uploaded to the browser.
 *
 * @param file - The file to check
 * @returns `true` if the file matches an image, audio, or video file.
 * @since 2.9.0
 */
export function isMediaFile(file: File): boolean {
  return isImageFile(file) || isAudioFile(file) || isVideoFile(file);
}

/**
 * One of the function names from a `FileReader` to upload a file to the
 * client.
 *
 * Note: If this file does not need to be previewed in the browser and will
 * immediately be uploaded to a server, use `readAsArrayBuffer`.
 *
 * @since 2.9.0
 * @since 6.0.0 Removed `"readAsBinaryString` since it is deprecated
 * {@see https://developer.mozilla.org/en-US/docs/Web/API/FileReader/readAsBinaryString}
 */
export type FileReaderParser =
  | "readAsText"
  | "readAsDataURL"
  | "readAsArrayBuffer";

/**
 * A function that should return one of the {@link FileReaderParser} functions
 * to start uploading a file to the browser.
 *
 * @example The Default File Upload Parser
 * ```ts
 * export const getFileParser: GetFileParser = (file) => {
 *   if (isMediaFile(file)) {
 *     return "readAsDataURL";
 *   }
 *
 *   if (isTextFile(file)) {
 *     return "readAsText";
 *   }
 *
 *   return "readAsArrayBuffer";
 * };
 * ```
 *
 * @param file - The file to get a parser for
 * @returns the {@link FileReaderParser} string.
 * @since 2.9.0
 */
export type GetFileParser = (file: File) => FileReaderParser;

/**
 * This function will attempt to read:
 * - media (image, audio, and video) files as a data url so they can be
 *   previewed in `<img>`, `<audio>`, and `<video>` tags
 * - text files as plain text
 * - everything else as an `ArrayBuffer` which can be manually converted into a
 *   data url if needed with `URL.createObjectURL`
 *
 * @since 2.9.0
 */
export const getFileParser: GetFileParser = (file) => {
  if (isMediaFile(file)) {
    return "readAsDataURL";
  }

  if (isTextFile(file)) {
    return "readAsText";
  }

  return "readAsArrayBuffer";
};

/** @since 2.9.0 */
export interface SplitFileUploads {
  readonly pending: readonly ProcessingFileUploadStats[];
  readonly uploading: readonly ProcessingFileUploadStats[];
  readonly complete: readonly CompletedFileUploadStats[];
}

/**
 * This util will split all the current upload stats by status.
 *
 * @param stats - The {@link FileUploadStats} list generally returned by the
 * {@link useFileUpload} hook.
 * @returns the {@link SplitFileUploads}.
 * @since 2.9.0
 */
export function getSplitFileUploads(
  stats: readonly FileUploadStats[]
): SplitFileUploads {
  const pending: ProcessingFileUploadStats[] = [];
  const uploading: ProcessingFileUploadStats[] = [];
  const complete: CompletedFileUploadStats[] = [];
  stats.forEach((stat) => {
    if (stat.status === "pending") {
      pending.push(stat);
    } else if (stat.status === "uploading") {
      uploading.push(stat);
    } else if (stat.status === "complete") {
      complete.push(stat);
    } else {
      /* istanbul ignore next */
      throw new Error("Invalid upload stat");
    }
  });

  return { pending, uploading, complete };
}
